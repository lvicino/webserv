<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Holographic Error</title>

  <style>
    * {
      margin: 0;
      padding: 0;
    }

    html, body {
      overflow: hidden;
      background-color: #1d1f2a;
    }

    .webgl {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      outline: none;
      display: block;
    }
  </style>

  <script type="importmap">
  {
      "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
      }
  }
  </script>
</head>
<body>
  <canvas class="webgl"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import GUI from 'three/addons/libs/lil-gui.module.min.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

const codeString = "404";

    const holoVertex = `
      uniform float uTime;
      varying vec3 vPosition;
      varying vec3 vNormal;

      float random2D(vec2 value) {
        return fract(sin(dot(value.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }

      void main() {
        vec4 modelPosition = modelMatrix * vec4(position, 1.0);

        float glitchTime = uTime - modelPosition.y;
        float glitchStrength = sin(glitchTime) + sin(glitchTime * 3.45) + sin(glitchTime * 8.76);
        glitchStrength /= 3.0;
        glitchStrength = smoothstep(0.3, 1.0, glitchStrength);
        glitchStrength *= 0.25;
        modelPosition.x += (random2D(modelPosition.xz + uTime) - 0.5) * glitchStrength;
        modelPosition.z += (random2D(modelPosition.zx + uTime) - 0.5) * glitchStrength;

        gl_Position = projectionMatrix * viewMatrix * modelPosition;

        vec4 modelNormal = modelMatrix * vec4(normal, 0.0);
        vPosition = modelPosition.xyz;
        vNormal = modelNormal.xyz;
      }
    `;

    const holoFragment = `
      uniform vec3 uColor;
      uniform float uTime;
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        vec3 normal = normalize(vNormal);
        if(!gl_FrontFacing)
          normal *= -1.0;

        float stripes = mod((vPosition.y - uTime * 0.02) * 20.0, 1.0);
        stripes = pow(stripes, 3.0);

        vec3 viewDirection = normalize(vPosition - cameraPosition);
        float fresnel = dot(viewDirection, normal) + 1.0;
        fresnel = pow(fresnel, 2.0);

        float falloff = smoothstep(0.8, 0.2, fresnel);

        float holographic = stripes * fresnel;
        holographic += fresnel * 1.25;
        holographic *= falloff;

        gl_FragColor = vec4(uColor, holographic);
        #include <tonemapping_fragment>
        #include <colorspace_fragment>
      }
    `;

    // Debug
    const gui = new GUI();

    // Canvas
    const canvas = document.querySelector('canvas.webgl');

    // Scene
    const scene = new THREE.Scene();

    // Loaders
    const gltfLoader = new GLTFLoader();
    const fontLoader = new FontLoader();

    // Sizes
    const sizes = {
      width: window.innerWidth,
      height: window.innerHeight
    };

    window.addEventListener('resize', () => {
      sizes.width = window.innerWidth;
      sizes.height = window.innerHeight;
      camera.aspect = sizes.width / sizes.height;
      camera.updateProjectionMatrix();
      renderer.setSize(sizes.width, sizes.height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    // Camera
    const camera = new THREE.PerspectiveCamera(25, sizes.width / sizes.height, 0.1, 100);
    camera.position.set(0, 0, 50);
    scene.add(camera);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;

    // Renderer
    const rendererParameters = { clearColor: '#1d1f2a' };
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setClearColor(rendererParameters.clearColor);
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    gui.addColor(rendererParameters, 'clearColor').onChange(() => {
      renderer.setClearColor(rendererParameters.clearColor);
    });

    // Material
    const materialParameters = { color: '#70c1ff' };
    const codeMaterial = new THREE.ShaderMaterial({
      vertexShader: holoVertex,
      fragmentShader: holoFragment,
      uniforms: {
        uTime: new THREE.Uniform(0),
        uColor: new THREE.Uniform(new THREE.Color(materialParameters.color)),
      },
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false,
    });

    gui.addColor(materialParameters, 'color').onChange(() => {
      codeMaterial.uniforms.uColor.value.set(materialParameters.color);
    });

    // Load Font (via CDN)
    const fontURL = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r180/examples/fonts/helvetiker_regular.typeface.json';
    let code1 = null, code2 = null, code3 = null;

    fontLoader.load(fontURL, (font) => {
      const createDigit = (char) => {
        const geometry = new TextGeometry(char, {
          font: font,
          size: 2,
          depth: 0.4,
          curveSegments: 20,
          bevelEnabled: true,
          bevelThickness: 0.03,
          bevelSize: 0.02,
          bevelOffset: 0,
          bevelSegments: 5
        });
        geometry.center();
        return new THREE.Mesh(geometry, codeMaterial);
      };

      code1 = createDigit(codeString[0]);
      code2 = createDigit(codeString[1]);
      code3 = createDigit(codeString[2]);

      code1.position.x = -2;
      code3.position.x = 2;
      scene.add(code1, code2, code3);
    });

    // Animate
    const clock = new THREE.Clock();

    const tick = () => {
      const elapsedTime = clock.getElapsedTime();
      codeMaterial.uniforms.uTime.value = elapsedTime;

      if (code1 && code2 && code3) {
        code1.rotation.x = -elapsedTime * 0.4;
        code1.rotation.y = elapsedTime * 0.8;
        code2.rotation.x = -elapsedTime * 0.4;
        code2.rotation.y = elapsedTime * 0.8;
        code3.rotation.x = -elapsedTime * 0.4;
        code3.rotation.y = elapsedTime * 0.8;
      }

      controls.update();
      renderer.render(scene, camera);
      window.requestAnimationFrame(tick);
    };

    tick();
  </script>
</body>
</html>
